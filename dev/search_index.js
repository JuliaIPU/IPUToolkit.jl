var documenterSearchIndex = {"docs":
[{"location":"compiler/#Writing-codelets-in-Julia","page":"Writing codelets","title":"Writing codelets in Julia","text":"","category":"section"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"The IPUToolkit.IPUCompiler submodule allows you to write codelets for the IPU in Julia. Codelets are defined with the @codelet macro, and then you can use them inside a program, written using the interface to the Poplar SDK described before. This mechanism uses the GPUCompiler.jl package, which is a generic framework for generating LLVM IR code for specialised targets, not limited to GPUs despite the historical name.","category":"page"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"Examples of codelets written in Julia are shown in the files examples/main.jl, examples/pi.jl, examples/adam.jl, examples/diffeq.jl.","category":"page"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"The code inside a codelet has the same limitations as all the compilation models based on GPUCompiler.jl:","category":"page"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"the code has to be statically inferred and compiled, dynamic dispatch is not admitted;\nyou cannot use functionalities which require the Julia runtime, most notably the garbage collector;\nyou cannot call into any other external binary library at runtime, for example you cannot call into a BLAS library.","category":"page"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"After defining a codelet with @codelet you can add a vertex calling this codelet to the graph with the function add_vertex, which also allows controlling the tile mapping in a basic way, or Poplar.GraphAddVertex.","category":"page"},{"location":"compiler/#IPUToolkit.IPUCompiler.@codelet","page":"Writing codelets","title":"IPUToolkit.IPUCompiler.@codelet","text":"@codelet graph <function definition>\n\nDefine a codelet and add it to the graph. The @codelet macro takes two argument:\n\nthe graph to which to add the codelet with the Poplar.GraphAddCodelets function;\nthe function definition of the codelet that you want to compile for the IPU device.\n\nAll the arguments of the function must be either VertexVectors, which represent the Vector vertex type in the Poplar SDK, or VertexScalars, which represent scalar arguments. The function passed as second argument to @codelet should have a single method.\n\n@codelet defines the function passed as argument, generates its LLVM Intermediate Representation (IR) using GPUCompiler.jl and then compiles it down to native code using the Poplar compiler popc, which must be in PATH. By default the LLVM IR of the function is written to a temporary file, but you can choose to keep it in the current directory by customising IPUCompiler.KEEP_LLVM_FILES. You can control flags passed to the popc compiler like debug and optimisation levels or target types by customising IPUCompiler.POPC_FLAGS. During compilation of codelets a spinner is displayed to show the progress, as this step can take a few seconds for each codelet to be generated. This can be disabled by setting IPUCompiler.PROGRESS_SPINNER. All the options mentioned in this section have to be set before the @codelet invocation where you want them to have effect.\n\nThe codelet is automatically added to the graph but you will have to separately use it in a vertex, by using either the add_vertex function, or Poplar's Poplar.GraphAddVertex.\n\nExample\n\nusing IPUToolkit.IPUCompiler, IPUToolkit.Poplar\ndevice = Poplar.get_ipu_device()\ntarget = Poplar.DeviceGetTarget(device)\ngraph = Poplar.Graph(target)\n@codelet graph function test(in::VertexVector{Int32,In}, out::VertexVector{Float32,Out})\n    for idx in eachindex(out)\n        out[idx] = sin(in[idx])\n    end\nend\n\nThis snippet of code defines a codelet called test, which takes in input the vector in, whose elements are Int32s, and modifies the vector out, of type Float32, by computing the sine of the elements of in.\n\n\n\n\n\n","category":"macro"},{"location":"compiler/#IPUToolkit.IPUCompiler.VertexVector","page":"Writing codelets","title":"IPUToolkit.IPUCompiler.VertexVector","text":"VertexVector{T, S} <: AbstractVector{T}\n\nThis datatype formally represents vectors to be used in codelets (vertices) in IPU programs. They are the counterpart of the vertex vector types in the Poplar SDK.\n\nThe parameters of VertexVector{T,S} are\n\nT: the type of the elements of the vector, e.g. Int32, Float32, etc.;\nS: the scope of the vector in the codelet, In, Out, or InOut.\n\nVertexVector is only meant to be used by end-user to define the arguments of codelets with the @codelet macro. You should not try to manually instantiate or access the fields of a VertexVector.\n\nFor scalar arguments use VertexScalar.\n\nExample\n\nVertexVector{Float32, In}    # input-only vector of `Float32` elements\nVertexVector{Int32, Out}     # output-only vector of `Int32` elements\nVertexVector{UInt32, InOut}  # input/output vector of `UInt32` elements\n\n\n\n\n\n","category":"type"},{"location":"compiler/#IPUToolkit.IPUCompiler.VertexScalar","page":"Writing codelets","title":"IPUToolkit.IPUCompiler.VertexScalar","text":"VertexScalar{T, S}\n\nThis datatype formally represents scalars to be used in codelets (vertices) in IPU programs. Technically, these are implemented as single-element tensors.\n\nThe parameters of VertexScalar{T,S} are\n\nT: the type of the scalar, e.g. Int32, Float32, etc.;\nS: the scope of the scalar in the codelet, In, Out, or InOut.\n\nVertexScalar is only meant to be used by end-user to define the arguments of codelets with the @codelet macro. You should not try to manually instantiate or access the fields of a VertexScalar.\n\nInside a codelet you can access and set the number by unwrapping it with [].\n\nFor vector arguments use VertexVector.\n\nExample\n\nExamples of types\n\nVertexScalar{Float32, In}    # input-only `Float32` number\nVertexScalar{Int32, Out}     # output-only `Int32` number\nVertexScalar{UInt32, InOut}  # input/output `UInt32` number\n\nInside a codelet, let x have type VertexScalar, you can access its value if it has scope In or InOut with\n\n@ipushow x[]\ny = x[] / 3.14\n\nIf x has scope Out or InOut you can set its value with x[] = ...:\n\nx[] = 3.14\n\n\n\n\n\n","category":"type"},{"location":"compiler/#IPUToolkit.IPUCompiler.add_vertex","page":"Writing codelets","title":"IPUToolkit.IPUCompiler.add_vertex","text":"add_vertex(graph::Poplar.GraphAllocated,\n           compute_set_or_program::Union{Poplar.ComputeSetAllocated, Poplar.ProgramSequenceAllocated},\n           [tiles::Union{Integer,AbstractVector{<:Integer}},]\n           codelet::Function,\n           args::Union{Number,Poplar.TensorAllocated}...) -> Nothing\n\nAdd the codelet function codelet created with @codelet to graph, using the tensors args as arguments. The function codelet must have exactly one method, no more, no less. The second argument can be either the program or the compute set to which to add the new vertex/vertices. If a program is passed, a new compute set will be automatically created.\n\nadd_vertex also evenly maps all tensors and vertices across all tiles, which can be either a single tile ID or an AbstractVector of IDs and defaults to single tile 0 if this argument is omitted. Note that all argument tensors args must be longer than or equal to the number of tiles. If you want to have better control over tile mapping, use Poplar.GraphAddVertex instead.\n\n\n\n\n\n","category":"function"},{"location":"compiler/#IPUToolkit.IPUCompiler.TARGET_COLOSSUS","page":"Writing codelets","title":"IPUToolkit.IPUCompiler.TARGET_COLOSSUS","text":"IPUToolkit.IPUCompiler.TARGET_COLOSSUS::Base.RefValue{Bool}\n\nOption to control whether to target the Colossus backend when generating the LLVM Intermediate Representation (IR) of the codelets. If set to false, the default, codelets will generate code for the host machine, which may be inefficient, while still being valid.\n\nnote: Note\nYou can target the Colossus backend only if your Julia links to a version of libllvm compiled from Graphcore's fork of LLVM.\n\nwarning: Warning\nThis option is experimental, Julia code generation using Graphcore's LLVM has not been tested extensively and is known to cause miscompilations, unexpected errors may happen.\n\nExample\n\nIPUToolkit.IPUCompiler.TARGET_COLOSSUS[] = false # Generate LLVM IR for the host, the default\nIPUToolkit.IPUCompiler.TARGET_COLOSSUS[] = true  # Generate LLVM IR for the Colossus backend\n\n\n\n\n\n","category":"constant"},{"location":"compiler/#IPUToolkit.IPUCompiler.KEEP_LLVM_FILES","page":"Writing codelets","title":"IPUToolkit.IPUCompiler.KEEP_LLVM_FILES","text":"IPUToolkit.IPUCompiler.KEEP_LLVM_FILES::Base.RefValue{Bool}\n\nOption to control whether to keep in the current directory the files with the LLVM Intermediate Representation (IR) generated for the codelets.\n\nExample\n\nIPUToolkit.IPUCompiler.KEEP_LLVM_FILES[] = false # Generated LLVM IR files are automatically deleted after compilation, default\nIPUToolkit.IPUCompiler.KEEP_LLVM_FILES[] = true  # Generated LLVM IR files are kept in the current directory\n\n\n\n\n\n","category":"constant"},{"location":"compiler/#IPUToolkit.IPUCompiler.POPC_FLAGS","page":"Writing codelets","title":"IPUToolkit.IPUCompiler.POPC_FLAGS","text":"IPUToolkit.IPUCompiler.POPC_FLAGS::Base.RefValue{Cmd}\n\nOptions to pass to the popc compiler to compile the code.\n\nExample\n\nIPUToolkit.IPUCompiler.POPC_FLAGS = `-O3 -g0 -target ipu2`\nIPUToolkit.IPUCompiler.POPC_FLAGS = `-O2 -g`\n\n\n\n\n\n","category":"constant"},{"location":"compiler/#IPUToolkit.IPUCompiler.PROGRESS_SPINNER","page":"Writing codelets","title":"IPUToolkit.IPUCompiler.PROGRESS_SPINNER","text":"IPUToolkit.IPUCompiler.PROGRESS_SPINNER::Base.RefValue{Bool}\n\nOption to control whether to display a spinner to show progress during compilation of IPU codelets. This is forcibly disabled if DEBUG_COMPILATION_ERRORS is true.\n\nExample\n\nIPUToolkit.IPUCompiler.PROGRESS_SPINNER[] = true  # enable spinner, default\nIPUToolkit.IPUCompiler.PROGRESS_SPINNER[] = false # disable spinner\n\n\n\n\n\n","category":"constant"},{"location":"compiler/#IPU-builtins","page":"Writing codelets","title":"IPU builtins","text":"","category":"section"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"Inside codelets defined with @codelet all calls to random functions","category":"page"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"rand(Float16)\nrand(Float32)\nrand(UInt32)\nrand(UInt64)\nrandn(Float16)\nrandn(Float32)","category":"page"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"result to call to corresponding IPU builtins for random number generation. The uniformly distributed numbers follow the general semantic of the Julia function rand (floating point numbers are uniformely distributed in the 0 1) range), while the normally distributed numbers have the properties described in the Poplar SDK documentation (numbers are in the range -9316 9316).","category":"page"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"note: Note\nThe IPU builtins for random numbers return pairs of numbers, but the Julia functions randn(Float16) and randn(Float32) return only a single number, discarding the second number of the pair. If you have a vector of even length that you want to fill in-place with normally distributed numbers, you can use the randn2! function to do that efficiently, without discarding any number.","category":"page"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"Additionally, you can use the IPU builtins listed below.","category":"page"},{"location":"compiler/#IPUToolkit.IPUCompiler.get_scount_l","page":"Writing codelets","title":"IPUToolkit.IPUCompiler.get_scount_l","text":"get_scount_l()\n\nCall the __builtin_ipu_get_scount_l() builtin:\n\nGet the value of the control/status register (CSR) SCOUNT_L, which is the lower 32 bits of the tile cycle counter value.\n\n\n\n\n\n","category":"function"},{"location":"compiler/#IPUToolkit.IPUCompiler.get_tile_id","page":"Writing codelets","title":"IPUToolkit.IPUCompiler.get_tile_id","text":"get_tile_id()\n\nCall the __builtin_ipu_get_tile_id() builtin:\n\nGet the tile ID of the current tile.\n\n\n\n\n\n","category":"function"},{"location":"compiler/#IPUToolkit.IPUCompiler.randn2!","page":"Writing codelets","title":"IPUToolkit.IPUCompiler.randn2!","text":"randn2!(v::VertexVector) -> v\n\nFill the vector v with normally-distributed (mean 0, standard deviation 1) random numbers. The vector must have even length. This function takes advantage of IPU builtins for random number generation, which return pairs of numbers at a time.\n\n\n\n\n\n","category":"function"},{"location":"compiler/#Printing","page":"Writing codelets","title":"Printing","text":"","category":"section"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"Inside codelets you can print text and value of variables using the macros @ipuprintf, @ipuprint, @ipuprintln, and @ipushow. These macros are useful for debugging purposes but printing inside a codelet might incur performance penalty. To completely disable all printing and make these macros no-op you can set IPUCompiler.DISABLE_PRINT:","category":"page"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"IPUCompiler.DISABLE_PRINT[] = true","category":"page"},{"location":"compiler/#IPUToolkit.IPUCompiler.@ipuprintf","page":"Writing codelets","title":"IPUToolkit.IPUCompiler.@ipuprintf","text":"@ipuprintf(\"%Fmt\", args...)\n\nPrint a formatted string in device context on the host standard output.\n\nNote that this is not a fully C-compliant printf implementation.\n\nAlso beware that it is an untyped, and unforgiving printf implementation. Type widths need to match, eg. printing a 64-bit Julia integer requires the %ld formatting string.\n\nMore user-friendly versions of this macro are @ipuprint, @ipuprintln. See also @ipushow, which is built on top of @ipuprintf functionalities.\n\nPrinting can be completely disabled by setting IPUCompiler.DISABLE_PRINT:\n\nIPUToolkit.IPUCompiler.DISABLE_PRINT[] = true\n\n\n\n\n\n","category":"macro"},{"location":"compiler/#IPUToolkit.IPUCompiler.@ipuprint","page":"Writing codelets","title":"IPUToolkit.IPUCompiler.@ipuprint","text":"@ipuprint(xs...)\n@ipuprintln(xs...)\n\nPrint a textual representation of values xs to standard output from the IPU. The functionality builds on @ipuprintf, and is intended as a more use friendly alternative of that API. However, that also means there's only limited support for argument types, handling 16/32/64 signed and unsigned integers, 32 and 64-bit floating point numbers, Cchars and pointers. For more complex output, use @ipuprintf directly.\n\nLimited string interpolation is also possible:\n\n    @ipuprint(\"Hello, World \", 42, \"\\n\")\n    @ipuprint \"Hello, World $(42)\\n\"\n\nPrinting can be completely disabled by setting IPUCompiler.DISABLE_PRINT:\n\nIPUToolkit.IPUCompiler.DISABLE_PRINT[] = true\n\n\n\n\n\n","category":"macro"},{"location":"compiler/#IPUToolkit.IPUCompiler.@ipuprintln","page":"Writing codelets","title":"IPUToolkit.IPUCompiler.@ipuprintln","text":"@ipuprint(xs...)\n@ipuprintln(xs...)\n\nPrint a textual representation of values xs to standard output from the IPU. The functionality builds on @ipuprintf, and is intended as a more use friendly alternative of that API. However, that also means there's only limited support for argument types, handling 16/32/64 signed and unsigned integers, 32 and 64-bit floating point numbers, Cchars and pointers. For more complex output, use @ipuprintf directly.\n\nLimited string interpolation is also possible:\n\n    @ipuprint(\"Hello, World \", 42, \"\\n\")\n    @ipuprint \"Hello, World $(42)\\n\"\n\nPrinting can be completely disabled by setting IPUCompiler.DISABLE_PRINT:\n\nIPUToolkit.IPUCompiler.DISABLE_PRINT[] = true\n\n\n\n\n\n","category":"macro"},{"location":"compiler/#IPUToolkit.IPUCompiler.@ipushow","page":"Writing codelets","title":"IPUToolkit.IPUCompiler.@ipushow","text":"@ipushow(ex)\n\nIPU analogue of Base.@show. It comes with the same type restrictions as @ipuprintf.\n\n@ipushow x\n\nPrinting can be completely disabled by setting IPUCompiler.DISABLE_PRINT:\n\nIPUToolkit.IPUCompiler.DISABLE_PRINT[] = true\n\n\n\n\n\n","category":"macro"},{"location":"compiler/#IPUToolkit.IPUCompiler.DISABLE_PRINT","page":"Writing codelets","title":"IPUToolkit.IPUCompiler.DISABLE_PRINT","text":"IPUToolkit.IPUCompiler.DISABLE_PRINT::Base.RefValue{Bool}\n\nGlobal constant which controls whether printing through the various @ipuprint* macros should be disabled or not.  You may want to completely disable printing for production runs, to avoid the cost of printing on the device, but keep it enabled during development.\n\nExamples:\n\nIPUToolkit.IPUCompiler.DISABLE_PRINT[] = false # Do not disable printing, this is the default.\nIPUToolkit.IPUCompiler.DISABLE_PRINT[] = true  # Disable printing, the `@ipuprint*` macros are no-op.\n\n\n\n\n\n","category":"constant"},{"location":"compiler/#Benchmarking","page":"Writing codelets","title":"Benchmarking","text":"","category":"section"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"To benchmark expressions inside codelets you can use the macros @ipucycles, @ipushowcycles, and @ipuelapsed, which report the number of cycles spent in the wrapped expression. They are similar to Julia's @time, @showtime, and @elapsed macros, but report the number of cycles, as the clockspeed of tiles cannot be easily obtained inside a codelet. The corresponding time can be obtained by dividing the number of cycles by the clock frequency of the the tile, which you can get with Poplar.TargetGetTileClockFrequency(target) outside of the codelet, and should usually be 1.330 GHz or 1.850 GHz depending on the model of your IPU. The printing macros @ipucycles and @ipushowcycles can be made completely no-op by setting IPUCompiler.DISABLE_PRINT.","category":"page"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"warning: Warning\nTiming of expressions taking longer than typemax(UInt32) / tile_clock_frequency (about 2 or 3 seconds depending on your IPU model) is unreliable because the difference between the starting and the ending cycle counts would overflow.Note also that the Poplar.TargetGetTileClockFrequency(target) function may not return a reliable value, but this is an upstream bug (this has been observed at least up to Poplar SDK v3.0). You may have to use tools like gc-monitor, gc-inventory, or gc-info --device-id <N> --tile-clock-speed to obtain the correct tile clock frequency.","category":"page"},{"location":"compiler/#IPUToolkit.IPUCompiler.@ipucycles","page":"Writing codelets","title":"IPUToolkit.IPUCompiler.@ipucycles","text":"@ipucycles ex\n@ipucycles \"description\" ex\n\nPrint from inside a codelet the number of cycles spent to compute the expression ex. The corresponding time can be obtained by dividing the number of cycles by the clock frequency of the the tile, which you can get with Poplar.TargetGetTileClockFrequency(target) outside of the codelet. The optional argument description, a literal String, can be used to print also a label to identify the timed expression. A label is added automatically by @ipushowcycles.\n\nSee also @ipuelapsed.\n\nThis macro can be made no-op completely by setting\n\nIPUToolkit.IPUCompiler.DISABLE_PRINT[] = true\n\n\n\n\n\n","category":"macro"},{"location":"compiler/#IPUToolkit.IPUCompiler.@ipushowcycles","page":"Writing codelets","title":"IPUToolkit.IPUCompiler.@ipushowcycles","text":"@ipushowcycles ex\n\nPrint from inside a codelet the expression ex and the number of cycles spent to compute it. This is useful when benchmarking multiple expression, to identify their contributions more easily. The corresponding time can be obtained by dividing the number of cycles by the clock frequency of the the tile, which you can get with Poplar.TargetGetTileClockFrequency(target) outside of the codelet.\n\nSee also @ipucycles, @ipuelapsed.\n\nThis macro can be made no-op completely by setting\n\nIPUToolkit.IPUCompiler.DISABLE_PRINT[] = true\n\n\n\n\n\n","category":"macro"},{"location":"compiler/#IPUToolkit.IPUCompiler.@ipuelapsed","page":"Writing codelets","title":"IPUToolkit.IPUCompiler.@ipuelapsed","text":"@ipuelapsed ex\n\nReturn number of cycles spent to compute the expression ex. The corresponding time can be obtained by dividing the number of cycles by the clock frequency of the the tile, which you can get with Poplar.TargetGetTileClockFrequency(target) outside of the codelet.\n\nSee also @ipucycles, @ipushowcycles.\n\n\n\n\n\n","category":"macro"},{"location":"compiler/#Passing-non-constant-variables-from-global-scope","page":"Writing codelets","title":"Passing non-constant variables from global scope","text":"","category":"section"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"If your kernel references a non-constant (const) global variable, the generated code will result in a reference to a memory address on the host, and this will fatally fail at runtime because programs running on the IPU don't have access to the host memory. Constant variables are not affected by this problem because their values are inlined when the function is compiled. If you can't or don't want to make a variable constant you can interpolate its value with a top-level @eval when defining the codelet. For example:","category":"page"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"using IPUToolkit.IPUCompiler, IPUToolkit.Poplar\ndevice = Poplar.get_ipu_device()\ntarget = Poplar.DeviceGetTarget(device)\ngraph = Poplar.Graph(target)\ntile_clock_frequency = Poplar.TargetGetTileClockFrequency(target)\n@eval @codelet graph function test(invec::VertexVector{Float32, In}, outvec::VertexVector{Float32, Out})\n    # We can use the intrinsic `get_scount_l` to get the cycle counter right\n    # before and after some operations, so that we can benchmark it.\n    cycles_start = get_scount_l()\n    # Do some operations here...\n    cycles_end = get_scount_l()\n    # Divide the difference between the two cycle counts by the tile frequency\n    # clock to get the time.\n    time = (cycles_end - cycles_start) / $(tile_clock_frequency)\n    # Show the time spent doing your operations\n    @ipushow time\nend","category":"page"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"The use of @eval allows you not to have to pass an extra argument to your kernel just to use the value of the variable inside the codelet.","category":"page"},{"location":"compiler/#Debugging-compilation-errors-in-codelets","page":"Writing codelets","title":"Debugging compilation errors in codelets","text":"","category":"section"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"Writing codelets for the IPU takes some practice, because you cannot use any arbitrary construct or package as you would normally do when running code on a CPU. As mentioned above, codelets have to be statically compiled with GPUCompiler.jl, with all the limitations of this framework, which can only use a subset of the Julia language. Therefore, it happens frequently that you run into compilation errors while developing a codelet function, and you have then to resolve the issues, which usually involves removing dynamic dispatch calls (which would require the JIT compiler at runtime), resolving type-instabilities, avoiding memory allocations, etc... If you have Cthulhu.jl installed, you can set IPUCompiler.DEBUG_COMPILATION_ERRORS to true to automatically open an interactive shell when compiling a codelet results into invalid LLVM IR, to more easily debug the codelet code.","category":"page"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"We suggest again taking a look at the code samples in the examples/ directory for learning how to write working IPU codelets in Julia.","category":"page"},{"location":"compiler/#IPUToolkit.IPUCompiler.DEBUG_COMPILATION_ERRORS","page":"Writing codelets","title":"IPUToolkit.IPUCompiler.DEBUG_COMPILATION_ERRORS","text":"IPUToolkit.IPUCompiler.DEBUG_COMPILATION_ERRORS::Base.RefValue{Bool}\n\nOption to control whether a failure to compile LLVM IR in @codelet should drop you into an interactive debug session with Cthulhu.jl. This forcibly disables the progress spinner enabled by PROGRESS_SPINNER, as it would not play nicely with the interactive debug session.\n\nnote: Note\nCthulhu.jl must be installed in the environment you are currently using and you have to run using Cthulhu before the @codelet definition. IPUToolkit.jl does not install Cthulhu.jl automatically to limit the number of dependencies.\n\nExample\n\nIPUToolkit.IPUCompiler.DEBUG_COMPILATION_ERRORS[] = false # Do not automatically open interactive debug shell when a compilation error arises, the default\nIPUToolkit.IPUCompiler.DEBUG_COMPILATION_ERRORS[] = true  # Automatically open interactive debug shell when a compilation error arises\n\n\n\n\n\n","category":"constant"},{"location":"compiler/#Domain-Specific-Language:-@ipuprogram","page":"Writing codelets","title":"Domain-Specific Language: @ipuprogram","text":"","category":"section"},{"location":"compiler/","page":"Writing codelets","title":"Writing codelets","text":"The IPUCompiler.@ipuprogram macro provides a very simple and limited DSL to automatically generate most of the boilerplate code needed when writing an IPU program. You can do very little with this DSL, which is mainly a showcase of Julia's meta-programming capabilities. A fully commented examples of use of the @ipuprogram macro is available in the examples/dsl.jl file.","category":"page"},{"location":"poplar/#Interfacing-the-Poplar-SDK","page":"Poplar SDK","title":"Interfacing the Poplar SDK","text":"","category":"section"},{"location":"poplar/","page":"Poplar SDK","title":"Poplar SDK","text":"A quick example of use of the Poplar SDK functionalities, available in the IPUToolkit.Poplar submodule:","category":"page"},{"location":"poplar/","page":"Poplar SDK","title":"Poplar SDK","text":"julia> using IPUToolkit.Poplar\n\njulia> dm = Poplar.DeviceManager();\n\njulia> Int(Poplar.DeviceManagerGetNumDevices(dm))\n129\n\njulia> device = Poplar.get_ipu_device();\n[ Info: Trying to attach to device 0...\n[ Info: Successfully attached to device 0\n\njulia> Int(Poplar.DeviceGetId(device))\n0\n\njulia> Poplar.detach_devices()","category":"page"},{"location":"poplar/","page":"Poplar SDK","title":"Poplar SDK","text":"A couple of basic examples of programs running on the IPU written using the interface to the Poplar SDK are available in the files examples/tutorial1.jl and examples/tutorial2.jl.","category":"page"},{"location":"poplar/","page":"Poplar SDK","title":"Poplar SDK","text":"We automatically generate the bindings of the Poplar SDK using Clang.jl and CxxWrap.jl. There is not automatic documentation at the moment, but functions can be accessed from the Poplar submodule. Also, the IPUToolkit.Poplar submodule wraps a subset of the functionalities available in the Poplar SDK, do not expect to be able to use all functionalities. Remember that Julia does not use class-based object-oriented programming, class instances will usually be first arguments of the methods you want to use.","category":"page"},{"location":"poplar/","page":"Poplar SDK","title":"Poplar SDK","text":"Function naming convention and signature is usually as follows:","category":"page"},{"location":"poplar/","page":"Poplar SDK","title":"Poplar SDK","text":"class name in CamelCase, followed by method name also in CamelCase.  Note that first letter of method name is always uppercase in this naming convention, even if it is lowercase in the Poplar SDK.  For example, the method getNumDevices of the DeviceManager class can be accessed in the Poplar submodule with Poplar.DeviceManagerGetNumDevices;\nthe first argument of the function is the class instance.  For example, to use the Julia function Poplar.DeviceManagerGetNumDevices, you need to pass as first argument an instance of DeviceManager;\nthe following arguments are the same as in the method you want to use in the SDK.  For example, the method getNumDevices of the DeviceManager class doesn't take any argument, so the Julia function Poplar.DeviceManagerGetNumDevices will take an instance of DeviceManager as only argument.","category":"page"},{"location":"poplar/#Convenient-methods","page":"Poplar SDK","title":"Convenient methods","text":"","category":"section"},{"location":"poplar/","page":"Poplar SDK","title":"Poplar SDK","text":"In addition to this, for some functions (e.g. EngineWriteTensor, EngineConnectStream, EngineReadTensor) we provide more user-friendly methods where the last argument can be a Julia's Array, without having to pass additional arguments for pointers or array size. Furthermore, the custom functions Poplar.get_ipu_device and Poplar.get_ipu_devices can be used to access one more IPU devices, as shown in the example above.","category":"page"},{"location":"poplar/","page":"Poplar SDK","title":"Poplar SDK","text":"Another function for which we provide a convenient method is Poplar.GraphAddConstant:","category":"page"},{"location":"poplar/","page":"Poplar SDK","title":"Poplar SDK","text":"Poplar.GraphAddConstant(graph, host_array)","category":"page"},{"location":"poplar/","page":"Poplar SDK","title":"Poplar SDK","text":"adds the host_array (a plain standard Julia Array living on the host) to graph, automatically inferring from host_array the type and the shape of the tensor in the graph. This works also with host_array::Array{Float16}.","category":"page"},{"location":"poplar/","page":"Poplar SDK","title":"Poplar SDK","text":"You can slice a tensor with the usual Julia notation tensor[index1:index2], this corresponds to a call to Tensor.slice(index1, index2+1).","category":"page"},{"location":"poplar/","page":"Poplar SDK","title":"Poplar SDK","text":"similar can be used to add to graph a tensor with the same shape and optionally element type as tensor, while copyto! can be used to copy elements of a CPU host array into an IPU tensor.","category":"page"},{"location":"poplar/#Using-IPUToolkit.jl-without-an-IPU","page":"Poplar SDK","title":"Using IPUToolkit.jl without an IPU","text":"","category":"section"},{"location":"poplar/","page":"Poplar SDK","title":"Poplar SDK","text":"While this package requires a physical IPU to use all the available features, you can still experiment with the IPU programming model even if you do not have access to a hardware IPU. The Poplar SDK provides a feature called IPU Model, which is a software emulation of the behaviour of the IPU hardware. While the IPU model comes with some limitations, it can be useful for testing or debugging.","category":"page"},{"location":"poplar/","page":"Poplar SDK","title":"Poplar SDK","text":"To use the IPU model in IPUToolkit.jl, define the device of your IPU program with Poplar.get_ipu_model:","category":"page"},{"location":"poplar/","page":"Poplar SDK","title":"Poplar SDK","text":"device = Poplar.get_ipu_model()\n# Then the rest of the program continues as usual\ntarget = Poplar.DeviceGetTarget(device)\ngraph = Poplar.Graph(target)\n# ...","category":"page"},{"location":"poplar/#Base.copyto!-Union{Tuple{T}, Tuple{IPUToolkit.Poplar.GraphAllocated, IPUToolkit.Poplar.TensorAllocated, Array{T}}} where T","page":"Poplar SDK","title":"Base.copyto!","text":"copyto!(\n    graph::Poplar.Graph,\n    dest::Poplar.TensorAllocated,\n    src::Array\n) -> Poplar.TensorAllocated\n\nIn the given graph copies the elements of the CPU host array src to the IPU tensor dest, using Graph::setInitialValue under the hood. The elements of src must have a type corresponding to the type of dest (e.g. Float16 for a half IPU tensor, or Float32 for a float IPU tensor). This function returns dest.\n\n\n\n\n\n","category":"method"},{"location":"poplar/#Base.similar-Tuple{IPUToolkit.Poplar.Graph, Union{IPUToolkit.Poplar.TensorAllocated, Array}}","page":"Poplar SDK","title":"Base.similar","text":"similar(\n    graph::Poplar.Graph,\n    tensor::Union{Poplar.TensorAllocated,Array},\n    [type::DataType],\n    [debug::String]\n) -> Poplar.TensorAllocated\n\nAdds to graph a variable tensor with the same shape as tensor, which can be either an IPU tensor or a plain CPU host Array, using Graph::addVariable under the hood. If a type (this is a Julia type, like Float32 or Int32) argument is not passed, the same element type as tensor will be automatically used. An optional debug context can also be passed, as a String. This function returns a pointer to the tensor added to the graph.\n\n\n\n\n\n","category":"method"},{"location":"poplar/#IPUToolkit.Poplar.detach_devices-Tuple{}","page":"Poplar SDK","title":"IPUToolkit.Poplar.detach_devices","text":"Poplar.detach_devices() -> Nothing\n\nDetach all devices previously attached in the current Julia session with Poplar.get_ipu_devices, Poplar.get_ipu_device, or Poplar.get_ipu_model.\n\n\n\n\n\n","category":"method"},{"location":"poplar/#IPUToolkit.Poplar.get_ipu_device","page":"Poplar SDK","title":"IPUToolkit.Poplar.get_ipu_device","text":"Poplar.get_ipu_device(hint::Union{AbstractVector{<:Integer},Integer}=0) -> Poplar.DeviceAllocated\n\nSimilar to Poplar.get_ipu_devices, but request exactly one IPU device.  If it can attach to a device, return that pointer only (not in a vector, like get_ipu_devices), otherwise return nothing.\n\nSee Poplar.get_ipu_model for requesting an IPU Model.\n\nYou can release the device with Poplar.DeviceDetach(device). To release all devices previously attached with Poplar.get_ipu_device, Poplar.get_ipu_devices, or Poplar.get_ipu_model use Poplar.detach_devices.\n\nThe optional argument hint suggests to which device IDs to try and attach.  It can have different types:\n\nif of type Integer, try to attach to one device, starting from the one with index hint. The default is hint=0;\nif of type AbstractVector, try to attach to a device from that list of IDs.\n\n\n\n\n\n","category":"function"},{"location":"poplar/#IPUToolkit.Poplar.get_ipu_devices","page":"Poplar SDK","title":"IPUToolkit.Poplar.get_ipu_devices","text":"Poplar.get_ipu_devices(n::Int, hint::Union{AbstractVector{<:Integer},Integer}=0) -> Vector{Poplar.DeviceAllocated}\n\nTry to attach to n IPU devices, returns a vector of the pointers to the devices successfully attached to.  You can release them with Poplar.DeviceDetach (note that this function takes a single pointer as input, so you have to use broadcasting Poplar.DeviceDetach.(devices) to release a vector of pointers).\n\nThe second optional argument hint suggests to which device IDs to try and attach.  It can have different types:\n\nif of type Integer, try to attach to n devices, starting from the one with index hint.  The default is hint=0;\nif of type AbstractVector, try to attach to n devices from that list of IDs.\n\nSee Poplar.get_ipu_device for requesting exactly one IPU device, and Poplar.get_ipu_model for requesting an IPU Model. To release all devices previously attached with Poplar.get_ipu_devices, Poplar.get_ipu_device, or Poplar.get_ipu_model use Poplar.detach_devices.\n\n\n\n\n\n","category":"function"},{"location":"poplar/#IPUToolkit.Poplar.get_ipu_model","page":"Poplar SDK","title":"IPUToolkit.Poplar.get_ipu_model","text":"Poplar.get_ipu_model(ipu_version::String=\"ipu2\") -> Poplar.DeviceAllocated\n\nAttach to an IPU Model, and return the attached device. This uses IPUModel::createDevice under the hood.\n\nThe optional positional argument ipu_version::String, ipu2 by default, represents the version of the IPU to emulate. Valid values for ipu_version are ipu1 and ipu2 (for Mk1 and Mk2 IPU architectures respectively).\n\nSee Poplar.get_ipu_device and Poplar.get_ipu_devices for requesting one or mode hardware IPUs.\n\nYou can release the device with Poplar.DeviceDetach(device). To release all devices previously attached with Poplar.get_ipu_model, Poplar.get_ipu_device or Poplar.get_ipu_devices use Poplar.detach_devices.\n\n\n\n\n\n","category":"function"},{"location":"poplar/#IPUToolkit.Poplar.@graph-Tuple{Any, Expr}","page":"Poplar SDK","title":"IPUToolkit.Poplar.@graph","text":"@graph [graph] expr\n\nThis is a convenient macro to automatically inject graph as first argument of all function calls in the expression passed as last argument to the macro.\n\nThe graph argument should be the graph object you want to pass as first argument to the function calls. If it is a local variable called exactly graph, this argument can be omitted and this name will be used automatically.\n\nnote: Note\nThis macro is not very sophisticated and will fail with complex expressions involving, for example, control flows like if or for. See the examples below.\n\nExamples\n\njulia> @macroexpand @graph begin\n           c1 = Poplar.GraphAddConstant(Float32[1.0, 1.5, 2.0, 2.5])\n           v1 = similar(c1, \"v1\")\n           copyto!(v1, Float32[4.0, 3.0, 2.0, 1.0])\n\n           Poplar.GraphSetTileMapping(c1, 0)\n           Poplar.GraphSetTileMapping(v1, 0)\n       end\nquote\n    c1 = Poplar.GraphAddConstant(graph, Float32[1.0, 1.5, 2.0, 2.5])\n    v1 = similar(graph, c1, \"v1\")\n    copyto!(graph, v1, Float32[4.0, 3.0, 2.0, 1.0])\n    Poplar.GraphSetTileMapping(graph, c1, 0)\n    Poplar.GraphSetTileMapping(graph, v1, 0)\nend\n\n\n\n\n\n","category":"macro"},{"location":"#IPUToolkit.jl","page":"IPUToolkit","title":"IPUToolkit.jl","text":"","category":"section"},{"location":"","page":"IPUToolkit","title":"IPUToolkit","text":"IPUToolkit.jl allows you to interface the Intelligence Processing Unit (IPU) by Graphcore using the Julia programming language.","category":"page"},{"location":"","page":"IPUToolkit","title":"IPUToolkit","text":"The main motivation for this project is to explore Julia's introspection and metaprogramming capabilities to write high-level code for the IPU using an alternative method to the tools developed by Graphcore, and leverage code-generation through LLVM to generate efficient code for the device: also the IPU compiler is based on this framework, so the LLVM IR constitutes a common language between Julia and the IPU compiler.","category":"page"},{"location":"","page":"IPUToolkit","title":"IPUToolkit","text":"warning: Disclaimer\nThis effort is not officially endorsed by Graphcore, although we gracefully received help through the public Graphcore support channels. This package is currently a proof-of-concept, not suitable for production usage. Its API may be subject to frequent development and breaking changes.","category":"page"},{"location":"","page":"IPUToolkit","title":"IPUToolkit","text":"This package was initially created by Emily Dietrich and Luk Burchard, and later expanded by Mosè Giordano. Mosè's work on this package was funded by UCL Centre for Advance Research Computing.","category":"page"},{"location":"#Requirements","page":"IPUToolkit","title":"Requirements","text":"","category":"section"},{"location":"","page":"IPUToolkit","title":"IPUToolkit","text":"This package requires","category":"page"},{"location":"","page":"IPUToolkit","title":"IPUToolkit","text":"Julia v1.6+ (currently tested up to Julia v1.10),\nthe Poplar SDK v1.3 or v2.0-v3.2 including the popc compiler,\na C++ compiler supporting C++17 standard for compiling the wrapper around the Poplar SDK (e.g. G++ 9 or following releases).","category":"page"},{"location":"","page":"IPUToolkit","title":"IPUToolkit","text":"Other versions of the Poplar SDK are not currently supported.","category":"page"},{"location":"","page":"IPUToolkit","title":"IPUToolkit","text":"note: Compatibility between Julia and Poplar SDK\nBoth Julia and the Poplar SDK are coupled to a specific version of the LLVM compiler framework, and you will need to match a specific version of the Poplar SDK with a version of Julia using the same major version of LLVM. For examplethe Poplar SDK version 2.2 uses LLVM 13, which is available in Julia v1.8;\nthe Poplar SDK versions 2.3-2.5 use LLVM 14, which is available in Julia v1.9;\nthe Poplar SDK versions 2.6-3.2 use LLVM 15, which is available in Julia v1.10;\nthe Poplar SDK version 3.3 uses LLVM 16, which is available in Julia v1.11 (NOTE: this combination has ***not*** been tested yet and is likely not to work at the moment).","category":"page"},{"location":"#Installation","page":"IPUToolkit","title":"Installation","text":"","category":"section"},{"location":"","page":"IPUToolkit","title":"IPUToolkit","text":"To install the package, run the commands","category":"page"},{"location":"","page":"IPUToolkit","title":"IPUToolkit","text":"using Pkg\nPkg.add(\"IPUToolkit\")","category":"page"},{"location":"","page":"IPUToolkit","title":"IPUToolkit","text":"You will need to build the wrapper around the Poplar SDK. This should happen automatically the first time you install the package, in any case you can run it with","category":"page"},{"location":"","page":"IPUToolkit","title":"IPUToolkit","text":"Pkg.build()","category":"page"},{"location":"","page":"IPUToolkit","title":"IPUToolkit","text":"This step requires a C++ compiler supporting C++17 standard. You have to set the compiler with the CXX environment variable, this can be either its absolute path or simply its name if it is in the PATH environment variable. The compiler must be able to find Poplar header files automatically, depending on your installation of the Poplar SDK you may have to add its include/ directory to the CPATH environment variable, but this should be done automatically by the script to activate a Poplar SDK.","category":"page"},{"location":"","page":"IPUToolkit","title":"IPUToolkit","text":"note: Note\nCompiling the wrapper around the Poplar SDK will take several minutes (up to about 7 minutes, depending on the Poplar version), without printing any progress to screen. Hold on.","category":"page"},{"location":"#Usage","page":"IPUToolkit","title":"Usage","text":"","category":"section"},{"location":"","page":"IPUToolkit","title":"IPUToolkit","text":"The package is called IPUToolkit because it provides different tools to interface the IPU from Julia:","category":"page"},{"location":"","page":"IPUToolkit","title":"IPUToolkit","text":"you can use functionalities in the Poplar SDK;\nyou can use Julia's code generation capabilities to automatically compile native code that can be run on the IPU;\nthere is a small embedded Domain-Specific Language (eDSL) to automatically generate the code of a program.","category":"page"},{"location":"","page":"IPUToolkit","title":"IPUToolkit","text":"These approaches are exploratory of the functionalities, and are often limited in scope and are described in more details in the following sections.","category":"page"},{"location":"#Talks-and-demos","page":"IPUToolkit","title":"Talks and demos","text":"","category":"section"},{"location":"","page":"IPUToolkit","title":"IPUToolkit","text":"Here is some material that you may find useful for learning more about Julia on the IPU and trying it out yourself:","category":"page"},{"location":"","page":"IPUToolkit","title":"IPUToolkit","text":"Pluto notebook of presentation given at Graphcore and at JuliaCon in July 2023\nTalk \"Julia meets the Intelligence Processing Unit\" at JuliaCon 2023\nTalk \"Automatic differentiation on the IPU with Enzyme.jl\" at EnzymeCon 2024","category":"page"}]
}
